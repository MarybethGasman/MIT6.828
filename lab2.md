# Lab: system calls

ä¸Šä¸ªå®éªŒlab1å…¨æ˜¯system programmingçš„å†…å®¹ï¼Œè·ŸOSè¿™ä¸ªä¸»é¢˜å…³ç³»ä¸æ˜¯å¾ˆå¤§ï¼Œåšçš„æˆ‘ä¹Ÿæ˜¯ä¸€æŠŠè¾›é…¸æ³ªã€‚

ä¸ºäº†å®Œæ•´æ€§æˆ‘è¿˜æ˜¯æŠŠlab1éƒ½è¿‡äº†ä¸€éã€‚æˆ‘ä¸ªäººæ¯”è¾ƒåœ¨æ„å¯¹äº‹ç‰©çš„è®¤çŸ¥è€Œä¸æ˜¯äº‹ç‰©æœ¬èº«ï¼Œæ‰€ä»¥æˆ‘çš„é‡ç‚¹éƒ½æ”¾åœ¨ç†è§£ä¸Šï¼Œå®é™…çš„ä»£ç éƒ½æ˜¯ä¸€å¸¦è€Œè¿‡ï¼Œè¿™å¯èƒ½ä¹Ÿæ˜¯æˆ‘codingä¸å¦‚åˆ«äººçš„åŸå› ã€‚ğŸ˜

#### ä¸€ï¼Œä¿®æ”¹kernelè®©trace

> In this assignment you will **add a system call** **tracing feature** that may help you when debugging later labs. You'll create a new `trace` system call that will control tracing. It should take one argument, an integer "mask", whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls `trace(1 << SYS_fork)`, where `SYS_fork` is a syscall number from `kernel/syscall.h`. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call's number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don't need to print the system call arguments. The `trace` system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.

ä¸€å¼€å§‹æˆ‘ä»¥ä¸ºè¦æ·»åŠ ä¸€ä¸ªsyscallå«traceï¼Œå®ƒèƒ½æ‰“å°å‡ºæŒ‡å®šå‘½ä»¤æ‰€ä½¿ç”¨çš„å¯¹åº”ç³»ç»Ÿè°ƒç”¨çš„è¿”å›å€¼å’Œåå­—ï¼ˆç±»ä¼¼äºstraceï¼‰ï¼Œå†™çš„æ—¶å€™å‘ç°å¾ˆéš¾ï¼Œåæ¥å‘ç°è‡ªå·±é¢˜è¯»é”™äº†ï¼Œaddçš„å®¾è¯­æ˜¯featureè€Œä¸æ˜¯system callï¼Œç¬‘æ­»ã€‚

æ¥ç¼•ä¸€ç¼•syscallçš„ä¸€èˆ¬æµç¨‹ï¼Œä»¥å½“å‰å®éªŒç¯å¢ƒxv6ä¸ºä¾‹ã€‚

é¦–å…ˆç”¨æˆ·æ€ç¨‹åºcallä¸€ä¸ªsyscallå‡½æ•°ï¼Œè¿™äº›å‡½æ•°çš„ç¬¦å·ï¼ˆfork,execç­‰ï¼‰ç”±å†…æ ¸æä¾›ï¼ˆå®šä¹‰åœ¨usys.Sï¼‰ï¼Œusys.Sä¼šæŠŠå¯¹åº”syscallçš„å·ç æ”¾å…¥å¯„å­˜å™¨ï¼Œç„¶åtrapè¿›kernelï¼ˆecallï¼‰ï¼Œè¿›å…¥ä¸­æ–­å¤„ç†å‡½æ•°ï¼Œä¸­æ–­å¤„ç†å‡½æ•°å‘ç°è¿™æ˜¯syscallä¼šè°ƒç”¨ä½äºkernel/syscall.cçš„syscallå‡½æ•°ï¼Œsyscallå‡½æ•°è´Ÿè´£æ ¹æ®ä¼ å…¥çš„å·ç è°ƒç”¨å¯¹åº”çš„å¤„ç†å‡½æ•°ï¼Œç„¶åè¿”å›ã€‚

é¦–å…ˆçœ‹usys.Sï¼Œåœ¨æœ¬å®éªŒç¯å¢ƒä¸­usys.Sç”±ä¸€ä¸ªå«åšusys.plçš„perlè„šæœ¬ç”Ÿæˆï¼Œå®šä¹‰äº†ç»™ç”¨æˆ·æ€ç¨‹åºä½¿ç”¨çš„æ‰€æœ‰syscallçš„ç¬¦å·ï¼Œå®ƒå°†syscallçš„å·ç ï¼ˆå®šä¹‰åœ¨syscall.hï¼‰å­˜å…¥a7å¯„å­˜å™¨ç„¶åå‘èµ·ä¸­æ–­ã€‚

```assembly
# generated by usys.pl - do not edit
#include "kernel/syscall.h"
.global fork
fork:
 li a7, SYS_fork
 ecall
 ret
...
```

ä¸­æ–­å¤„ç†å‡½æ•°ä¸€èˆ¬æ˜¯åœ¨ç³»ç»Ÿå¼€æœºçš„æ—¶å€™è®¾ç½®çš„ï¼ˆæŠŠè¿™äº›å‡½æ•°çš„å…¥å£æ‘†æ”¾åˆ°CPUçº¦å®šå¥½çš„ä½ç½®ï¼‰ï¼Œæˆ‘è¿™é‡Œå°±ä¸ç»†çœ‹ç³»ç»Ÿå¼€æœºçš„ä»£ç äº†ï¼ˆä½äºstart.cã€main.cï¼‰ã€‚

ä¸­æ–­å¤„ç†å‡½æ•°ï¼ˆæˆ–è€…æ˜¯subroutineï¼‰ä¸€èˆ¬ç”¨æ±‡ç¼–è¯­è¨€ç¼–å†™ï¼Œå› ä¸ºä»£ç ä¸å…·ä½“çš„CPUæ¶æ„ç›¸å…³ï¼Œåœ¨Linuxä»“åº“ä¸­è¿™äº›ä»£ç ä¸€èˆ¬ä½äºarchç›®å½•ä¸‹ï¼Œè¿™äº›ä»£ç åŸºæœ¬ä¸Šæ˜¯è®¾ç½®é«˜çº§è¯­è¨€ï¼ˆcè¯­è¨€ï¼‰çš„è¿è¡Œç¯å¢ƒç„¶åæŠŠæ§åˆ¶æƒäº¤ç»™é«˜çº§è¯­è¨€ç¼–å†™çš„å‡½æ•°ã€‚

kernel modeå’Œuser modeçš„åˆ‡æ¢å®šä¹‰åœ¨*trampoline.S*æ–‡ä»¶ä¸­ï¼Œæ±‡ç¼–ä»£ç çš„ä½œç”¨åˆšåˆšå·²ç»è¯´è¿‡ï¼Œå°±ä¸ç»†çœ‹äº†ï¼Œuservecå­routineæœ€åè°ƒç”¨äº†ä½äºkernel/trap.cçš„*usertrap*å‡½æ•°ã€‚

```c
void
usertrap(void)
{
  ...
  if(r_scause() == 8){
    // system call

    if(p->killed)
      exit(-1);

    // sepc points to the ecall instruction,
    // but we want to return to the next instruction.
    p->trapframe->epc += 4;

    // an interrupt will change sstatus &c registers,
    // so don't enable until done with those registers.
    intr_on();

    syscall();
  } else if((which_dev = devintr()) != 0){
    // ok
  } else {
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
    p->killed = 1;
  }
 ...
}
```

å¦‚æœæ˜¯trapçš„åŸå› æ˜¯syscallæœ€åä¼šè°ƒç”¨ä½äºsyscall.cçš„syscallå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ç”¨äºåˆ†å‘è¯·æ±‚ã€‚

æƒ³èµ·æ¥objective-cçš„åˆ†å‘å‡½æ•°ï¼Œspringmvcçš„dispatcherï¼Œmvcæ¶æ„çš„controllerï¼Œå¾®æœåŠ¡çš„APIç½‘å…³ï¼Œçª—å£ç®¡ç†å™¨ï¼Œå®ƒä»¬å’Œä¸­æ–­å¤„ç†ç¨‹åºå·®ä¸å¤šï¼Œéƒ½æ˜¯è´Ÿè´£æ ¹æ®è¯·æ±‚ç±»å‹è°ƒç”¨ä¸åŒçš„å¤„ç†å‡½æ•°ã€‚coolğŸ˜

æƒ³è®©kernelæ¯äº§ç”Ÿä¸€ä¸ªsyscallå°±æ‰“å°å…¶åå­—å’Œè¿”å›å€¼ï¼Œåªéœ€è¦ä¿®æ”¹åˆ†å‘å‡½æ•°syscallå³å¯

```c
void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();
    printf("xxxxx")//æ‡’å¾—å†™äº†ï¼Œè¿”å›å€¼åœ¨p->trapframe->a0ï¼Œåå­—è‡ªå·±å†™ä¸ªæ•°ç»„å¯¹åº”å°±å¥½ã€‚
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}

```

è¿˜æœ‰ä¸ªoptionalçš„ç»ƒä¹ æ˜¯æ‰“å°å‚æ•°çš„ï¼Œæ— éæ˜¯æ ¹æ®ABIå‡½æ•°è°ƒç”¨çº¦å®šå»æ‰¾å¯¹åº”å¯„å­˜å™¨çš„å€¼ï¼Œè¿™äº›å¯„å­˜å™¨çš„å€¼åœ¨ä¸­æ–­å¤„ç†ç¨‹åºä¸­æ—©å°±è¢«copyåˆ°åƒprocç­‰ç»“æ„ä½“ä¸­äº†ï¼Œæˆ‘å°±ä¸åšäº†ã€‚

#### äºŒï¼Œæ·»åŠ ä¸€ä¸ªå«Sysinfoçš„ç³»ç»Ÿè°ƒç”¨

è¿™æ¬¡æˆ‘å¾ˆç¡®å®šæ˜¯æ·»åŠ ç³»ç»Ÿè°ƒç”¨ï¼Œè€Œä¸æ˜¯ä»€ä¹ˆkernel featureã€‚

> In this assignment you will **add a system call**, `sysinfo`, that collects information about the running system. The system call takes one argument: a pointer to a `struct sysinfo` (see `kernel/sysinfo.h`). The kernel should fill out the fields of this struct: **the `freemem` field should be set to the number of bytes of free memory, and the `nproc` field should be set to the number of processes whose `state` is not `UNUSED`**. We provide a test program `sysinfotest`; you pass this assignment if it prints "sysinfotest: OK".

åœ¨å¼€å§‹ç¼–å†™ä»£ç ä¹‹å‰éœ€è¦å»user/user.hä¸­æ·»åŠ å¯¹åº”çš„prototypeï¼Œå‘Šè¯‰ç”¨æˆ·ä½ æœ‰ä¸€ä¸ªæ–°çš„æ¥å£å¯ä¾›ä½¿ç”¨ã€‚

ç„¶åå»usys.plç”Ÿæˆå¯¹åº”çš„å…¥å£

æœ€åå»syscall.hæ·»åŠ ä½ çš„å·ç ä»¥åŠå»syscallè¡¨ä¸­æ·»åŠ å·ç æŒ‡å‘çš„å‡½æ•°



ç„¶åæ·»åŠ è¿›å…¥ç‚¹çš„ç”Ÿæˆè„šæœ¬ï¼Œç”¨æ¥ç”Ÿæˆusys.Sçš„æ±‡ç¼–ä»£ç ã€‚

```
// user/usys.pl
entry("trace");
```

å¯¹äºentryè¿™ä¸ªsubroutineæˆ‘ä»¬åªéœ€è¦çŸ¥é“ä¸‹é¢è¿™ä¸€è¡Œå°±è¡Œï¼Œå½“ç”¨æˆ·è°ƒç”¨traceç³»ç»Ÿè°ƒç”¨ï¼Œä¼šè°ƒç”¨cè¯­è¨€çš„SYS_traceå‡½æ•°ã€‚

```perl
// user/usys.pl
print " li a7, SYS_${name}\n"; #æŠŠå®šä¹‰åœ¨syscall.hçš„ç³»ç»Ÿè°ƒç”¨å·loadè¿›a7å¯„å­˜å™¨
print " ecall\n";
print " ret\n";
```

