# Lab: system calls

上个实验lab1全是system programming的内容，跟OS这个主题关系不是很大，做的我也是一把辛酸泪。

为了完整性我还是把lab1都过了一遍。我个人比较在意对事物的认知而不是事物本身，所以我的重点都放在理解上，实际的代码都是一带而过，这可能也是我coding不如别人的原因。😁

#### 一，修改kernel让trace

> In this assignment you will **add a system call** **tracing feature** that may help you when debugging later labs. You'll create a new `trace` system call that will control tracing. It should take one argument, an integer "mask", whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls `trace(1 << SYS_fork)`, where `SYS_fork` is a syscall number from `kernel/syscall.h`. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call's number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don't need to print the system call arguments. The `trace` system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.

一开始我以为要添加一个syscall叫trace，它能打印出指定命令所使用的对应系统调用的返回值和名字（类似于strace），写的时候发现很难，后来发现自己题读错了，add的宾语是feature而不是system call，笑死。

来缕一缕syscall的一般流程，以当前实验环境xv6为例。

首先用户态程序call一个syscall函数，这些函数的符号（fork,exec等）由内核提供（定义在usys.S），usys.S会把对应syscall的号码放入寄存器，然后trap进kernel（ecall），进入中断处理函数，中断处理函数发现这是syscall会调用位于kernel/syscall.c的syscall函数，syscall函数负责根据传入的号码调用对应的处理函数，然后返回。

首先看usys.S，在本实验环境中usys.S由一个叫做usys.pl的perl脚本生成，定义了给用户态程序使用的所有syscall的符号，它将syscall的号码（定义在syscall.h）存入a7寄存器然后发起中断。

```assembly
# generated by usys.pl - do not edit
#include "kernel/syscall.h"
.global fork
fork:
 li a7, SYS_fork
 ecall
 ret
...
```

中断处理函数一般是在系统开机的时候设置的（把这些函数的入口摆放到CPU约定好的位置），我这里就不细看系统开机的代码了（位于start.c、main.c）。

中断处理函数（或者是subroutine）一般用汇编语言编写，因为代码与具体的CPU架构相关，在Linux仓库中这些代码一般位于arch目录下，这些代码基本上是设置高级语言（c语言）的运行环境然后把控制权交给高级语言编写的函数。

kernel mode和user mode的切换定义在*trampoline.S*文件中，汇编代码的作用刚刚已经说过，就不细看了，uservec子routine最后调用了位于kernel/trap.c的*usertrap*函数。

```c
void
usertrap(void)
{
  ...
  if(r_scause() == 8){
    // system call

    if(p->killed)
      exit(-1);

    // sepc points to the ecall instruction,
    // but we want to return to the next instruction.
    p->trapframe->epc += 4;

    // an interrupt will change sstatus &c registers,
    // so don't enable until done with those registers.
    intr_on();

    syscall();
  } else if((which_dev = devintr()) != 0){
    // ok
  } else {
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
    p->killed = 1;
  }
 ...
}
```

如果是trap的原因是syscall最后会调用位于syscall.c的syscall函数，这个函数用于分发请求。

想起来objective-c的分发函数，springmvc的dispatcher，mvc架构的controller，微服务的API网关，窗口管理器，它们和中断处理程序差不多，都是负责根据请求类型调用不同的处理函数。cool😎

想让kernel每产生一个syscall就打印其名字和返回值，只需要修改分发函数syscall即可

```c
void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();
    printf("xxxxx")//懒得写了，返回值在p->trapframe->a0，名字自己写个数组对应就好。
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}

```

还有个optional的练习是打印参数的，无非是根据ABI函数调用约定去找对应寄存器的值，这些寄存器的值在中断处理程序中早就被copy到像proc等结构体中了，我就不做了。

#### 二，添加一个叫Sysinfo的系统调用

这次我很确定是添加系统调用，而不是什么kernel feature。

> In this assignment you will **add a system call**, `sysinfo`, that collects information about the running system. The system call takes one argument: a pointer to a `struct sysinfo` (see `kernel/sysinfo.h`). The kernel should fill out the fields of this struct: **the `freemem` field should be set to the number of bytes of free memory, and the `nproc` field should be set to the number of processes whose `state` is not `UNUSED`**. We provide a test program `sysinfotest`; you pass this assignment if it prints "sysinfotest: OK".

在开始编写代码之前需要去user/user.h中添加对应的prototype，告诉用户你有一个新的接口可供使用。

然后去usys.pl生成对应的入口

最后去syscall.h添加你的号码以及去syscall表中添加号码指向的函数



然后添加进入点的生成脚本，用来生成usys.S的汇编代码。

```
// user/usys.pl
entry("trace");
```

对于entry这个subroutine我们只需要知道下面这一行就行，当用户调用trace系统调用，会调用c语言的SYS_trace函数。

```perl
// user/usys.pl
print " li a7, SYS_${name}\n"; #把定义在syscall.h的系统调用号load进a7寄存器
print " ecall\n";
print " ret\n";
```

在继续之前，我们先梳理一下xv6这个实验环境下系统调用的过程，首先是usertrap函数，它调用syscall。

```c
// kernel/trap.c
void usertrap(void) {
  int which_dev = 0;

  if((r_sstatus() & SSTATUS_SPP) != 0)
    panic("usertrap: not from user mode");

  // send interrupts and exceptions to kerneltrap(),
  // since we're now in the kernel.
  w_stvec((uint64)kernelvec);

  struct proc *p = myproc();
  
  // save user program counter.
  p->trapframe->epc = r_sepc();
  
  if(r_scause() == 8){
    // system call

    if(p->killed)
      exit(-1);

    // sepc points to the ecall instruction,
    // but we want to return to the next instruction.
    p->trapframe->epc += 4;

    // an interrupt will change sstatus &c registers,
    // so don't enable until done with those registers.
    intr_on();

    syscall();
  } else if((which_dev = devintr()) != 0){
    // ok
  } else {
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
    p->killed = 1;
  }

  if(p->killed)
    exit(-1);

  // give up the CPU if this is a timer interrupt.
  if(which_dev == 2)
    yield();

  usertrapret();
}
```

拿到a7寄存器的值，然后调用对应的syscall函数

```c
// kernel/syscall.c
void syscall(void) {
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```

