# Lab: system calls

ä¸Šä¸ªå®žéªŒlab1å…¨æ˜¯system programmingçš„å†…å®¹ï¼Œè·ŸOSè¿™ä¸ªä¸»é¢˜å…³ç³»ä¸æ˜¯å¾ˆå¤§ï¼Œåšçš„æˆ‘ä¹Ÿæ˜¯ä¸€æŠŠè¾›é…¸æ³ªã€‚

ä¸ºäº†å®Œæ•´æ€§æˆ‘è¿˜æ˜¯æŠŠlab1éƒ½è¿‡äº†ä¸€éã€‚æˆ‘ä¸ªäººæ¯”è¾ƒåœ¨æ„å¯¹äº‹ç‰©çš„è®¤çŸ¥è€Œä¸æ˜¯äº‹ç‰©æœ¬èº«ï¼Œæ‰€ä»¥æˆ‘çš„é‡ç‚¹éƒ½æ”¾åœ¨ç†è§£ä¸Šï¼Œå®žé™…çš„ä»£ç éƒ½æ˜¯ä¸€å¸¦è€Œè¿‡ï¼Œè¿™å¯èƒ½ä¹Ÿæ˜¯æˆ‘codingä¸å¦‚åˆ«äººçš„åŽŸå› ã€‚ðŸ˜

#### ä¸€ï¼Œä¿®æ”¹kernelè®©trace

> In this assignment you will **add a system call** **tracing feature** that may help you when debugging later labs. You'll create a new `trace` system call that will control tracing. It should take one argument, an integer "mask", whose bits specify which system calls to trace. For example, to trace the fork system call, a program calls `trace(1 << SYS_fork)`, where `SYS_fork` is a syscall number from `kernel/syscall.h`. You have to modify the xv6 kernel to print out a line when each system call is about to return, if the system call's number is set in the mask. The line should contain the process id, the name of the system call and the return value; you don't need to print the system call arguments. The `trace` system call should enable tracing for the process that calls it and any children that it subsequently forks, but should not affect other processes.

ä¸€å¼€å§‹æˆ‘ä»¥ä¸ºè¦æ·»åŠ ä¸€ä¸ªsyscallå«traceï¼Œå®ƒèƒ½æ‰“å°å‡ºæŒ‡å®šå‘½ä»¤æ‰€ä½¿ç”¨çš„å¯¹åº”ç³»ç»Ÿè°ƒç”¨çš„è¿”å›žå€¼å’Œåå­—ï¼ˆç±»ä¼¼äºŽstraceï¼‰ï¼Œå†™çš„æ—¶å€™å‘çŽ°å¾ˆéš¾ï¼ŒåŽæ¥å‘çŽ°è‡ªå·±é¢˜è¯»é”™äº†ï¼Œaddçš„å®¾è¯­æ˜¯featureè€Œä¸æ˜¯system callï¼Œç¬‘æ­»ã€‚

æ¥ç¼•ä¸€ç¼•syscallçš„ä¸€èˆ¬æµç¨‹ï¼Œä»¥å½“å‰å®žéªŒçŽ¯å¢ƒxv6ä¸ºä¾‹ã€‚

é¦–å…ˆç”¨æˆ·æ€ç¨‹åºcallä¸€ä¸ªsyscallå‡½æ•°ï¼Œè¿™äº›å‡½æ•°çš„ç¬¦å·ï¼ˆfork,execç­‰ï¼‰ç”±å†…æ ¸æä¾›ï¼ˆå®šä¹‰åœ¨usys.Sï¼‰ï¼Œusys.Sä¼šæŠŠå¯¹åº”syscallçš„å·ç æ”¾å…¥å¯„å­˜å™¨ï¼Œç„¶åŽtrapè¿›kernelï¼ˆecallï¼‰ï¼Œè¿›å…¥ä¸­æ–­å¤„ç†å‡½æ•°ï¼Œä¸­æ–­å¤„ç†å‡½æ•°å‘çŽ°è¿™æ˜¯syscallä¼šè°ƒç”¨ä½äºŽkernel/syscall.cçš„syscallå‡½æ•°ï¼Œsyscallå‡½æ•°è´Ÿè´£æ ¹æ®ä¼ å…¥çš„å·ç è°ƒç”¨å¯¹åº”çš„å¤„ç†å‡½æ•°ï¼Œç„¶åŽè¿”å›žã€‚

é¦–å…ˆçœ‹usys.Sï¼Œåœ¨æœ¬å®žéªŒçŽ¯å¢ƒä¸­usys.Sç”±ä¸€ä¸ªå«åšusys.plçš„perlè„šæœ¬ç”Ÿæˆï¼Œå®šä¹‰äº†ç»™ç”¨æˆ·æ€ç¨‹åºä½¿ç”¨çš„æ‰€æœ‰syscallçš„ç¬¦å·ï¼Œå®ƒå°†syscallçš„å·ç ï¼ˆå®šä¹‰åœ¨syscall.hï¼‰å­˜å…¥a7å¯„å­˜å™¨ç„¶åŽå‘èµ·ä¸­æ–­ã€‚

```assembly
# generated by usys.pl - do not edit
#include "kernel/syscall.h"
.global fork
fork:
 li a7, SYS_fork
 ecall
 ret
...
```

ä¸­æ–­å¤„ç†å‡½æ•°ä¸€èˆ¬æ˜¯åœ¨ç³»ç»Ÿå¼€æœºçš„æ—¶å€™è®¾ç½®çš„ï¼ˆæŠŠè¿™äº›å‡½æ•°çš„å…¥å£æ‘†æ”¾åˆ°CPUçº¦å®šå¥½çš„ä½ç½®ï¼‰ï¼Œæˆ‘è¿™é‡Œå°±ä¸ç»†çœ‹ç³»ç»Ÿå¼€æœºçš„ä»£ç äº†ï¼ˆä½äºŽstart.cã€main.cï¼‰ã€‚

ä¸­æ–­å¤„ç†å‡½æ•°ï¼ˆæˆ–è€…æ˜¯subroutineï¼‰ä¸€èˆ¬ç”¨æ±‡ç¼–è¯­è¨€ç¼–å†™ï¼Œå› ä¸ºä»£ç ä¸Žå…·ä½“çš„CPUæž¶æž„ç›¸å…³ï¼Œåœ¨Linuxä»“åº“ä¸­è¿™äº›ä»£ç ä¸€èˆ¬ä½äºŽarchç›®å½•ä¸‹ï¼Œè¿™äº›ä»£ç åŸºæœ¬ä¸Šæ˜¯è®¾ç½®é«˜çº§è¯­è¨€ï¼ˆcè¯­è¨€ï¼‰çš„è¿è¡ŒçŽ¯å¢ƒç„¶åŽæŠŠæŽ§åˆ¶æƒäº¤ç»™é«˜çº§è¯­è¨€ç¼–å†™çš„å‡½æ•°ã€‚

kernel modeå’Œuser modeçš„åˆ‡æ¢å®šä¹‰åœ¨*trampoline.S*æ–‡ä»¶ä¸­ï¼Œæ±‡ç¼–ä»£ç çš„ä½œç”¨åˆšåˆšå·²ç»è¯´è¿‡ï¼Œå°±ä¸ç»†çœ‹äº†ï¼Œuservecå­routineæœ€åŽè°ƒç”¨äº†ä½äºŽkernel/trap.cçš„*usertrap*å‡½æ•°ã€‚

```c
void
usertrap(void)
{
  ...
  if(r_scause() == 8){
    // system call

    if(p->killed)
      exit(-1);

    // sepc points to the ecall instruction,
    // but we want to return to the next instruction.
    p->trapframe->epc += 4;

    // an interrupt will change sstatus &c registers,
    // so don't enable until done with those registers.
    intr_on();

    syscall();
  } else if((which_dev = devintr()) != 0){
    // ok
  } else {
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
    p->killed = 1;
  }
 ...
}
```

å¦‚æžœæ˜¯trapçš„åŽŸå› æ˜¯syscallæœ€åŽä¼šè°ƒç”¨ä½äºŽsyscall.cçš„syscallå‡½æ•°ï¼Œè¿™ä¸ªå‡½æ•°ç”¨äºŽåˆ†å‘è¯·æ±‚ã€‚

æƒ³èµ·æ¥objective-cçš„åˆ†å‘å‡½æ•°ï¼Œspringmvcçš„dispatcherï¼Œmvcæž¶æž„çš„controllerï¼Œå¾®æœåŠ¡çš„APIç½‘å…³ï¼Œçª—å£ç®¡ç†å™¨ï¼Œå®ƒä»¬å’Œä¸­æ–­å¤„ç†ç¨‹åºå·®ä¸å¤šï¼Œéƒ½æ˜¯è´Ÿè´£æ ¹æ®è¯·æ±‚ç±»åž‹è°ƒç”¨ä¸åŒçš„å¤„ç†å‡½æ•°ã€‚coolðŸ˜Ž

æƒ³è®©kernelæ¯äº§ç”Ÿä¸€ä¸ªsyscallå°±æ‰“å°å…¶åå­—å’Œè¿”å›žå€¼ï¼Œåªéœ€è¦ä¿®æ”¹åˆ†å‘å‡½æ•°syscallå³å¯

```c
void
syscall(void)
{
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();
    printf("xxxxx")//æ‡’å¾—å†™äº†ï¼Œè¿”å›žå€¼åœ¨p->trapframe->a0ï¼Œåå­—è‡ªå·±å†™ä¸ªæ•°ç»„å¯¹åº”å°±å¥½ã€‚
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}

```

è¿˜æœ‰ä¸ªoptionalçš„ç»ƒä¹ æ˜¯æ‰“å°å‚æ•°çš„ï¼Œæ— éžæ˜¯æ ¹æ®ABIå‡½æ•°è°ƒç”¨çº¦å®šåŽ»æ‰¾å¯¹åº”å¯„å­˜å™¨çš„å€¼ï¼Œè¿™äº›å¯„å­˜å™¨çš„å€¼åœ¨ä¸­æ–­å¤„ç†ç¨‹åºä¸­æ—©å°±è¢«copyåˆ°åƒprocç­‰ç»“æž„ä½“ä¸­äº†ï¼Œæˆ‘å°±ä¸åšäº†ã€‚

#### äºŒï¼Œæ·»åŠ ä¸€ä¸ªå«Sysinfoçš„ç³»ç»Ÿè°ƒç”¨

è¿™æ¬¡æˆ‘å¾ˆç¡®å®šæ˜¯æ·»åŠ ç³»ç»Ÿè°ƒç”¨ï¼Œè€Œä¸æ˜¯ä»€ä¹ˆkernel featureã€‚

> In this assignment you will **add a system call**, `sysinfo`, that collects information about the running system. The system call takes one argument: a pointer to a `struct sysinfo` (see `kernel/sysinfo.h`). The kernel should fill out the fields of this struct: **the `freemem` field should be set to the number of bytes of free memory, and the `nproc` field should be set to the number of processes whose `state` is not `UNUSED`**. We provide a test program `sysinfotest`; you pass this assignment if it prints "sysinfotest: OK".

åœ¨å¼€å§‹ç¼–å†™ä»£ç ä¹‹å‰éœ€è¦åŽ»user/user.hä¸­æ·»åŠ å¯¹åº”çš„prototypeï¼Œå‘Šè¯‰ç”¨æˆ·ä½ æœ‰ä¸€ä¸ªæ–°çš„æŽ¥å£å¯ä¾›ä½¿ç”¨ã€‚

ç„¶åŽåŽ»usys.plç”Ÿæˆå¯¹åº”çš„å…¥å£

æœ€åŽåŽ»syscall.hæ·»åŠ ä½ çš„å·ç ä»¥åŠåŽ»syscallè¡¨ä¸­æ·»åŠ å·ç æŒ‡å‘çš„å‡½æ•°



ç„¶åŽæ·»åŠ è¿›å…¥ç‚¹çš„ç”Ÿæˆè„šæœ¬ï¼Œç”¨æ¥ç”Ÿæˆusys.Sçš„æ±‡ç¼–ä»£ç ã€‚

```
// user/usys.pl
entry("trace");
```

å¯¹äºŽentryè¿™ä¸ªsubroutineæˆ‘ä»¬åªéœ€è¦çŸ¥é“ä¸‹é¢è¿™ä¸€è¡Œå°±è¡Œï¼Œå½“ç”¨æˆ·è°ƒç”¨traceç³»ç»Ÿè°ƒç”¨ï¼Œä¼šè°ƒç”¨cè¯­è¨€çš„SYS_traceå‡½æ•°ã€‚

```perl
// user/usys.pl
print " li a7, SYS_${name}\n"; #æŠŠå®šä¹‰åœ¨syscall.hçš„ç³»ç»Ÿè°ƒç”¨å·loadè¿›a7å¯„å­˜å™¨
print " ecall\n";
print " ret\n";
```

åœ¨ç»§ç»­ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆæ¢³ç†ä¸€ä¸‹xv6è¿™ä¸ªå®žéªŒçŽ¯å¢ƒä¸‹ç³»ç»Ÿè°ƒç”¨çš„è¿‡ç¨‹ï¼Œé¦–å…ˆæ˜¯usertrapå‡½æ•°ï¼Œå®ƒè°ƒç”¨syscallã€‚

```c
// kernel/trap.c
void usertrap(void) {
  int which_dev = 0;

  if((r_sstatus() & SSTATUS_SPP) != 0)
    panic("usertrap: not from user mode");

  // send interrupts and exceptions to kerneltrap(),
  // since we're now in the kernel.
  w_stvec((uint64)kernelvec);

  struct proc *p = myproc();
  
  // save user program counter.
  p->trapframe->epc = r_sepc();
  
  if(r_scause() == 8){
    // system call

    if(p->killed)
      exit(-1);

    // sepc points to the ecall instruction,
    // but we want to return to the next instruction.
    p->trapframe->epc += 4;

    // an interrupt will change sstatus &c registers,
    // so don't enable until done with those registers.
    intr_on();

    syscall();
  } else if((which_dev = devintr()) != 0){
    // ok
  } else {
    printf("usertrap(): unexpected scause %p pid=%d\n", r_scause(), p->pid);
    printf("            sepc=%p stval=%p\n", r_sepc(), r_stval());
    p->killed = 1;
  }

  if(p->killed)
    exit(-1);

  // give up the CPU if this is a timer interrupt.
  if(which_dev == 2)
    yield();

  usertrapret();
}
```

æ‹¿åˆ°a7å¯„å­˜å™¨çš„å€¼ï¼Œç„¶åŽè°ƒç”¨å¯¹åº”çš„syscallå‡½æ•°

```c
// kernel/syscall.c
void syscall(void) {
  int num;
  struct proc *p = myproc();

  num = p->trapframe->a7;
  if(num > 0 && num < NELEM(syscalls) && syscalls[num]) {
    p->trapframe->a0 = syscalls[num]();
  } else {
    printf("%d %s: unknown sys call %d\n",
            p->pid, p->name, num);
    p->trapframe->a0 = -1;
  }
}
```

